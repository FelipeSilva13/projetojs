<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8"/>
    <TItle>UNIDADE 1</TItle>
    <Link rel="stylesheet" type="text/css" href="_css/index.css"/>
    
</head>
<body>
    
    
    
        

<header id="cabecalho">
<hgroup>
 <h1 id="livro">ENGENHARIA E PROJETO DE SOFTWARE</h1>   
<h1 id="unidade1">UNIDADE 1 <br>
EVOLUÇÃO DO SOFTWARE, FUNDAMENTOS DE ENGENHARIA DE SOFTWARE,<br> CICLO DE VIDA DE DESENVOLVIMENTO DE SOFTWARE E<br> REQUISITO DE SOFTWARE </h1>
<h2 id="topico1">TÓPICO 1 EVOLUÇÃO DO SOFTWARE </h2>
</hgroup>
<nav id="menu">
   
        
<h1 id="menu">MENU</h1>
<ul type="disc">
    <li><a href="unid1.html"><button type="button">Unidade 1</button></a></li>
    <li><a href="../unidade2/unid2.html"><button type="button">Unidade 2</button></a></li>
    <li><a href="../unidade3/unid3.html"><button type="button">Unidade 3</button></a></li>

</ul>
</nav>
</header>
<div id="unidade1">
<h3>1 INTRODUÇÃO </h3>
<p>A evolução do software confunde-se com a evolução dos computadores, inicialmente compostos apenas do hardware, onde toda a lógica de processamento era executada no meio físico. Porém, à medida que o hardware evolui, o software também acompanha essa mudança devido à necessidade de se tornar acessível ao usuário final.</p>

<p>O computador necessita que o software e o hardware andem em paralelo, para que haja um melhor aproveitamento dos recursos. De nada adianta o melhor hardware do mundo usando um sistema operacional defasado, tanto como um aplicativo de última geração tentar rodar em um hardware antigo e desatualizado.</p>

<p>A evolução do software passa, também, pelas características históricas do hardware. Roger Pressman (2009), guru da Engenharia de Software, define o software como componentes não executáveis em máquina e componentes executáveis em máquina. Explica-nos que o software é criado por meio de uma série de regras que mapeiam as exigências de negócios que são desenvolvidos em linguagem de programação, que especifica a estrutura de seus dados, os atributos procedimentais e os requisitos relacionados para código e os converte em instruções executáveis em máquina.</p>

<p>O software engloba códigos que executam funções entre si e, normalmente, retornam alguma informação ao usuário. Para a criação do software, os programadores utilizam uma linguagem de programação, que é interpretada por um compilador, que a transforma para código binário, o qual é lido pelo hardware.

    <p>Para entendermos essa definição, segue um pouco da história da “era do computador”.</p>

    <p>O primeiro computador surgiu para fins militares na década de 1940, o “Mark I” (tradução por tanque de guerra), foi financiado pela Marinha norte-americana em conjunto com a Universidade de Harvard e a IBM, onde ocupava, aproximadamente, 120 m³ e tinha 4,5 toneladas. Um gigante eletromagnético lançado no ano de 1944 para auxiliar nos cálculos de precisão necessários para balística (BERNARDES, 2015). </p><br><br>

FIGURA 1 - MARK I <br>
 <img src="_imagens/fig1.png"> 




 <p>Nessa época, devido às limitações da “linguagem máquina”, as operações para realizar os processos eram complexas, demandando várias pessoas para manter o funcionamento dos computadores. No período, uma das criações mais notáveiss – influenciando, inclusive, na Segunda Guerra Mundial – foi a máquina de Alan Turing, que foi capaz de decifrar os códigos utilizados pela Alemanha. Turing é considerado uma das maiores mentes na Ciência da Computação, tendo vários conceitos sendo estudados ainda nos dias atuais, como a Inteligência Artificial (IA).</p>

 <p>Na mesma década, em 1946, surgiu o primeiro computador eletrônico à válvula (relés eletromagnéticos e máquinas perfuradoras de cartões), desenvolvido por Eckert e Mauchly, o “ENIAC” (Electronic Numerical Integrator and Computer ou Computador Integrador Numérico Eletrônico), cuja velocidade de processamento era superior à do Mark I e configurações mais próximas dos computadores atuais. Ocupava, aproximadamente, 180 m² e tinha 30 toneladas. Sua memória era muito pequena, e a cada nova operação era necessário reconfigurar toda a sua fiação, exigindo um enorme esforço humano. </p>            

FIGURA 2 - ENIAC <br>
<img src="_imagens/fig2.png">






<p>A principal mudança da primeira geração para a segunda foi a substituição da válvula para o transistor, deixando-se de utilizar a linguagem de máquina para a programação em Assembly, facilitada por dispositivos de entrada e saída, melhorando a comunicação homem-máquina.</p>

<p>Portanto, o primeiro computador eletrônico com programa armazenado foi o “EDVAC” (Electronic Discrete Variable Automatic Computer ou Computador Eletrônico com Discreta Variação Automática), desenvolvido por Von Neumann. Utilizava o sistema binário, uma máquina digital de armazenamento ("memória") para comportar, respectivamente, instruções e dados na mesma unidade de processamento (CPU), podendo, assim, manipular tais programas. Tornou-se a arquitetura padrão para os computadores mais modernos, pois era dotado de cem vezes mais memória interna do que o ENIAC, um grande salto para a época, e ocupava 45,5 m² com quase oito toneladas (BERNARDES, 2015).</p>

FIGURA 3 - EDVAC <br>
<img src="_imagens/fig3.png">





<p>Em 1949, Maurice Wilkes criou o EDSAC (Eletronic Delay Storage Automatic Calculator ou Calculadora Automática com Armazenamento por Retardo Eletrônico), o primeiro computador operacional em grande escala capaz de armazenar seus próprios programas.</p>

<p>Na década de 50 surgiu o primeiro computador comercial do mundo, o LEO (Escritório Eletrônico de Lyons), que começou a automatizar os trabalhos de escritórios, criado através da parceria entre a J. Lyons e a Universidade de Cambridge e começou a ser utilizado em 1954.</p>

FIGURA 4 - LEO <br>
<img src="_imagens/fig4.png">






<p>A partir de 1953, o uso de circuitos integrados diminuiu o tamanho dos computadores e a empresa IBM começou a comercializar o computador IBM 701, onde eram utilizados cartões perfurados para o armazenamento de programas e dados.</p>

FIGURA 5 - CONSOLE DO IBM 701 <br>
<img src="_imagens/fig5.png">





<p>No final dos anos 60, o acesso a informações ficou mais rápido, foram introduzidas linguagens de alto nível, como Cobol e Fortran, complementadas por sistemas de armazenamento em disco e fitas magnéticas. Com o surgimento das linguagens imperativas Cobol e Fortran, as possibilidades de programação se expandiram vastamente. </p>

<p>O Cobol ainda é utilizado amplamente nos dias atuais em ambientes de mainframe, principalmente em bancos, devido à sua estabilidade, recebendo até expansão para ser utilizado como linguagem orientada a objeto. Outro ponto é o custo para realizar a migração e integração de dados para uma plataforma mais atual, que é muito alto. </p>

<h3>2 EVOLUÇÃO DO SOFTWARE </h3>
<p>Conforme visto, o desenvolvimento do software está estreitamente ligado há mais de cinco décadas de evolução do hardware, culminando em menor tamanho do hardware, fazendo com que sistemas baseados em computadores se tornassem mais sofisticados. Evoluímos dos processadores à válvula para os dispositivos microeletrônicos, que são capazes de processar milhares de instruções por segundo. A figura a seguir descreve a evolução do software dentro do contexto das áreas de aplicação de sistemas baseados em computador. </p>

FIGURA 6 – A EVOLUÇÃO DO SOFTWARE <br>
<img src="_imagens/fig6.png">




<p>Conforme destacado por Azevedo (2015), a evolução do software possui as seguintes características:</p>

<p>Os primeiros anos: como já visto anteriormente, no início, o hardware sofreu contínuas mudanças e o software foi incorporando-se aos poucos nesta evolução, na qual o hardware dedicava-se à execução de um único programa que, por sua vez, dedicava-se a uma única aplicação específica. Tinha-se uma distribuição limitada e com poucos métodos sistemáticos. Como característica usava uma orientação batch (em lote) para a maioria dos sistemas.</p><p>A maior parte dos softwares era desenvolvida e usada pela própria empresa e quem escrevia e colocava em funcionamento também tratava dos defeitos, e por conta do ambiente de software personalizado, o projeto era um processo implícito, realizado no cérebro de alguém, e a documentação muitas vezes não existia.
<p>A segunda era: entre a década de 1960 até o final da década de 1970 foi o período da multiprogramação. Os sistemas multiusuários ofereceram sofisticação de software e hardware, melhorando a interação homem-máquina. Houve o surgimento de sistemas de tempo real que podiam coletar, analisar e transformar dados de múltiplas fontes. Os avanços da armazenagem online levaram à primeira geração de sistemas de gerenciamento de banco de dados e surgimento dos softwares houses. Os programas para mainframes e minicomputadores eram distribuídos para centenas e, às vezes, milhares de usuários, e à medida que cresciam, devido à natureza personalizada de muitos programas, tornava-os virtualmente impossíveis de sofrerem manutenção. Uma "crise de software" agigantou-se no horizonte.</p>
<p> conceitos e a origem da engenharia de software, a fim de eliminar esta crise, bem como suas características, poderão ser vistos na página 15, Tópico 2, desta unidade de ensino. </p>


<p> terceira era: começou em meados da década de 1970 e continua até hoje. Existência dos sistemas distribuídos e múltiplos computadores, onde cada um, executando funções concorrentemente e comunicando-se um com o outro, aumenta intensamente a complexidade dos sistemas baseados em computador. </p><p> As redes globais, as comunicações digitais de largura de banda elevada e a crescente demanda de acesso "instantâneo" a dados exigem muito dos desenvolvedores de software.</p> Foi caracterizada, também, pelo advento e o generalizado uso de microprocessadores, computadores pessoais e poderosas estações de trabalho "workstations" de mesa. O microprocessador gerou um amplo conjunto de produtos inteligentes. Do automóvel a fornos micro-ondas, de robôs industriais a equipamentos para diagnóstico de soro sanguíneo. Em muitos casos, a tecnologia de software está sendo integrada a produtos, por equipes técnicas que entendem de hardware, mas que frequentemente são principiantes em desenvolvimento de software. O hardware de computador pessoal está se tornando rapidamente um produto primário, enquanto o software oferece a característica capaz de diferenciar.
<p>A quarta era: esta era está apenas começando. As tecnologias orientadas a objetos, orientadas a documentos, estão ocupando o lugar das abordagens mais convencionais para o desenvolvimento de software em muitas áreas de aplicação. As técnicas de "quarta geração" para o desenvolvimento de software já estão mudando a maneira segundo a qual alguns segmentos da comunidade de software constroem programas de computador. Os sistemas especialistas e o software de inteligência artificial finalmente saíram do laboratório para a aplicação prática em problemas de amplo espectro do mundo real. </p><p>O software de rede neural artificial abriu excitantes possibilidades para o reconhecimento de padrões e para capacidades de processamento de informações semelhantes às humanas.
<p>Era atual: a sofisticação do software ultrapassou nossa capacidade de construir um software que extraia o potencial do hardware. A capacidade de construir programas não acompanha o ritmo da demanda de novos programas, a capacidade de manter os programas existentes é ameaçada por projetos ruins e recursos inadequados e as práticas de engenharia de software se fortalecem.</p>
<h3>3 TIPOS DE SOFTWARE DO PONTO DE VISTA DA ENGENHARIA</h3>
<p>O software é um conjunto de algoritmos codificados que permite ao computador executar uma operação ou um conjunto de operações culminando em tarefas. Analisaremos, aqui, os tipos de software disponíveis, bem como a função e utilidade desses tipos de software.</p>

 

<p>Segundo Azevedo (apud Verzello, 1984), o software é classificado em três tipos: (1) Software de sistema, que são programas escritos para controlar e coordenar o software; (2) Software de linguagens, que são programas que traduzem outros programas para a forma binária, que é a linguagem utilizada pelos componentes do sistema computacional para mantê-los salvos em bancos de dados especiais; e, por último, (3) Software de aplicação, que são programas escritos para resolver problemas comerciais ou prestar outros serviços de processamento de dados aos usuários.</p>

 

<p>Roger Pressman (1995), porém, amplia essa classificação de software em sete diferentes categorias, afirmando ser uma tarefa um tanto difícil desenvolver categorias genéricas para aplicações de softwares, pois, no mesmo passo que o software cresce, desaparece a visão de compartimentos:</p>

<p>Software Básico: é uma coleção de programas que dão apoio a outros programas. É caracterizado pela forte interação com hardware, intenso uso por múltiplos usuários; operações concorrentes que exigem escalonamento schedule; compartilhamento de recursos e sofisticada administração do processo; estruturas de dados complexas e múltiplas interfaces externas. Exemplo: compiladores, editores simples, drivers, componentes do SO.</p>
<p>Software de Tempo Real: monitorar, analisar e controlar eventos do mundo real, caracterizado pela coleta de dados do ambiente externo, análise que transforma a informação de acordo com a necessidade do sistema, controle e saída para um ambiente externo e um componente de monitoração que coordena todos os outros. O termo tempo real difere de interativo ou tempo compartilhado, pois deve responder dentro de restrições de tempos exatos sem resultados desastrosos.</p>
<p>Software Comercial: facilita as operações comerciais e decisões administrativas. As aplicações dessa área reestruturam os dados de uma forma que facilita as operações comerciais e as tomadas de decisões administrativas. Além da aplicação de processamento de dados convencional, as aplicações de software comerciais abrangem a computação interativa. Exemplos: controle de estoque, finanças, vendas etc.</p>
<p>Software Científico e de Engenharia: algoritmos com intenso processamento de números e cálculos. As aplicações diversificadas variam da análise de fadiga mecânica de automóveis à dinâmica orbital de naves espaciais recuperáveis, e da biologia molecular à manufatura automatizada. Exemplos: sistemas de astronomia, naves espaciais, matemática avançada etc.</p>
<p>Software Embutido: é usado para controlar produtos e sistemas para mercados industriais e de consumo, pode utilizar memória de somente leitura e usa rotinas limitadas e particulares. O software embutido reside na memória só de leitura (read only) e pode executar funções limitadas e particulares (por exemplo, controle de teclado para fornos de micro-ondas) ou oferecer recursos funcionais de controle significativos (por exemplo, funções digitais em automóveis, tais como controle, mostradores no painel, sistemas de freio etc.).</p>
<p>Software de computador pessoal: utilizados em computadores de uso pessoal. Exemplos: editores de texto, planilhas, calculadora, jogos, computação gráfica, gerenciamento de dados, aplicações financeiras pessoais e comerciais, redes externas ou acesso a banco de dados, são apenas algumas das centenas de aplicações.</p>
<p>Software de inteligência artificial: faz uso de algoritmos não numéricos para resolver problemas complexos que não sejam favoráveis à computação ou à análise direta. Atualmente, a área de Artificial Inteligency (AI) mais ativa é a dos sistemas especialistas baseados em conhecimentos, porém outras áreas de aplicação para o software de AI são o reconhecimento de padrões (voz e imagem), jogos e demonstração de teoremas. Uma rede neural simula a estrutura dos processos cerebrais (a função do neurônio biológico) e pode levar a uma nova classe de software que consegue reconhecer padrões complexos e aprender com a experiência passada. Exemplos: sistema de reconhecimento de imagem, sistemas especialistas, redes neurais e aprendizado etc.</p>
<p>Diante do contexto histórico da evolução do computador, podemos perceber que o software é um elemento de sistema lógico e complexo, projetado pela engenharia, e o hardware, um elemento físico projetado por manufatura. Ambos apresentam características diferentes quanto à forma de utilização. Por exemplo: com o passar dos tempos, o hardware vai desgastando-se, exigindo manutenção, e o software, por sua vez, deteriora-se, exigindo sua evolução (vide Figura 7).</p>

 

<p>Os índices de falhas são relativamente elevados logo no começo do ciclo de vida do hardware, os defeitos são corrigidos e o índice de falhas cai para estável, porém, à medida que o tempo passa, o índice de falhas eleva-se novamente, conforme os componentes de hardware vão sofrendo males ambientais (poeira, vibração, abuso, temperaturas extremas etc.).</p>

FIGURA 7 - CURVAS DE FALHAS PARA O HARDWARE <br>
<img src="_imagens/fig7.png">





<p>Já o software não é sensível aos problemas ambientais. Os defeitos não descobertos no começo da vida de um programa provocarão elevados índices de falhas; após corrigidas, a curva achata-se; entretanto, fica claro que o software não se desgasta. Todavia, se deteriora! </p>

FIGURA 8 - CURVA DE FALHAS DO SOFTWARE (IDEALIZADA) <br>
<img src="_imagens/fig8.png">




<p>Portanto, segundo Amparo (2015), esta aparente contradição pode ser mais bem explicada considerando a Figura 9. Durante sua vida, o software enfrentará mudanças (manutenção). Quando estas são feitas, é provável que novos defeitos sejam introduzidos, fazendo com que a curva do índice de falhas apresente picos.</p>

FIGURA 9 - CURVA DE FALHAS REAL PARA O SOFTWARE <br>
<img src="_imagens/fig9.png" alt="">





<p>Percebe-se que a manutenção do software envolve consideravelmente mais complexidade do que a de hardware. Basta substituir um componente de hardware por uma peça de reposição; já com o software não existe reposição de peças, toda falha indica um erro de projeto ou no processo por meio do qual o projeto é especificado e traduzido em código executável por máquina.</p>

É necessário antecipar os caminhos em que o software sofre mudanças, dessa forma pode-se modificá-lo mais facilmente para acomodar tais necessidades. Porém, antecipar-se às mudanças não é uma tarefa fácil, uma vez que existem muitas razões pelas quais os sistemas mudam.</p>

Diante destes fatores, a engenharia de software vem para justificar que as principais causas estão na introdução de erros no processo de execução dos projetos de software. Ocorrem devido a projetos com má especificação, mal planejados, sem treinamentos, má implementação, testes incompletos ou mal feitos e, por fim, problemas na comunicação homem-máquina.</p>


Furtado (2007) conclui que, com o passar do tempo, os softwares vão “envelhecendo”, sua estrutura se torna ultrapassada e, por já não satisfazerem suas tarefas como antes, são descartados. O software é inerentemente flexível e pode ser alterado. Raramente é necessário descartar um software inteiro por ele não ser capaz de realizar determinada tarefa ou atingir um novo resultado. Em determinadas circunstâncias é preferível adaptar o software ao invés de eliminá-lo totalmente. Porém, para que isso seja possível é necessário que sejam adotadas técnicas de evolução de software, dessa forma o processo de reestruturação de um software pode ser possível, evitando que ele perca sua utilidade.</p>

Estas técnicas de evolução devem auxiliar o software a não sofrer tantos impactos após sucessivas versões. Como as modificações estão presentes na vida de um software, faz-se necessário utilizar controles a fim de reverter o envelhecimento do software, ou seja, adiar o dia em que este já não poderá ser mais viável.</p>

</div>